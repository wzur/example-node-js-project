An example of a Node.js application
===================================

## Table of Contents

- [Before you start](#before-you-start)
- [TL;DR](#tldr)
- [What does it do](#what-does-it-do)
- [Web Application](#web-application)
- [Dockerized Web Application](#dockerized-web-application)
- [Docker container orchestration](#docker-container-orchestration)
- [Requirements](#requirements)

_(TOC generated by [markdown-toc](https://github.com/jonschlinkert/markdown-toc))_

Before you start
----------------

This project builds and starts Docker container. You have to have a local Docker engine installed first.

TL;DR
-----

```bash
virtualenv venv
. venv/bin/activate
pip install -r requirements-lock.txt
docker-compose up --build -d && python test.py --port 443 --cert-path ./nginx/localhost.crt
```

What does it do
---------------

* Creates a simple Node.js application from [server.js]
* Packages a simple Node.js application into a Docker container, see [Dockerfile]
* Orchestrates Nginx to be in a front of the Node.js application and a Redis server to act as a database for
the application with Docker compose, see [docker-compose.yml]
* Test the application with a Python script ([test.py]), taken from https://github.com/paxosglobal/devops-test-script
* Redis database is stored in on a Docker volume

Web Application
---------------

This is very simple web application, based on [ExpressJS]. It defines two main entry API points:

* `/messages` - receives and stores a message sent with a `POST` request
* `/crasher` - crashes an application, to demonstrate auto-healing capabilities of Docker compose

The message is a simple JSON hash, with a single key `message`:

```json
{
  "message": "Please store me"
}
```

When a message is received, its SHA256 digest is returned:

```json
{
  "digest": "dc020a7f0087da9f0abb37efd402cd71e2a54532be6d7572a37c76af297c2643"
}
```

This digest can be used to fetch the message from the service:

```json
GET /message/dc020a7f0087da9f0abb37efd402cd71e2a54532be6d7572a37c76af297c2643
```

The application accepts following environment variables for its configuration

* `REDIS_HOST`: the location of the Redis server, used for the message storage, default is `localhost`
* `REDIS_PORT`: the port of the Redis server, default is `6379`
* `PORT`: the port the application should start to listen to, default is `5000`

Dockerized Web Application
--------------------------

The Node.js application is packaged into a Docker container with a [Dockerfile]. It uses Alpine flavour of
NodeJS container to make it slimmer.

It simply installs the web app to `/usr/src/app` with `npm install` of the dependencies
and a local copy of the Node.js sources.

Docker container orchestration
------------------------------

The [docker-compose.yml] demostrates how to build & start a Docker container with
the Node.js application (the `app` service). As the application requires a Redis
server, it is started alongside it (the `db` service). The Nginx HTTP daemon (the `web` service)
is used mainly as a frontend and handler of the SSL traffic, which is terminated there.

Nginx uses a self-signed [localhost.crt] certificate. It has been generated with
the following command:

```bash
openssl req -x509 -nodes \
  -days 365 \
  -newkey rsa:2048 \
  -subj '/CN=localhost' \
  -keyout nginx/localhost.key \
  -out nginx/localhost.crt
```

Requirements
------------

* Node.js
* Python
* Virtualenv
* Docker engine

[Dockerfile]: ./Dockerfile
[docker-compose.yml]: ./docker-compose.yml
[server.js]: ./server.js
[test.py]: ./test.py
[localhost.crt]: ./nginx/localhost.crt
[ExpressJS]: https://expressjs.com "Fast, unopinionated, minimalist web framework for Node.js"
